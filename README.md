# **ðŸ”® Z-Metric: A Universal Frame Shift Corrector**

This repository contains the proof-of-concept for the **Z-Metric framework** and the **Numberspace Conjecture**. It presents a novel method for analyzing discrete domains by treating observable patterns (like the prime number distribution) not as random, but as relativistic artifacts of linear observation.  
The core of this work is a universally applicable system for modeling and correcting these "observational frame shifts." The primary implementation, src/main/main.py, applies this framework to efficiently classify prime numbers.

### **Key Concepts**

* **The Numberspace Conjecture:** Posits that all discrete domains (integers, financial data, etc.) possess a holistic, interconnected structure. The patterns we see are emergent properties based on how we observe this structure.  
* **The Universal Frame Shift (UFS):** The act of linear, sequential observation (e.g., an algorithm iterating n \+= 1\) creates a relativistic discrepancy between the observer's frame of reference and the true, instantaneous state of the system.  
* **The Z-Transformation:** A set of equations that acts as a universal correction filter for the UFS. It transforms reference-frame-dependent data into invariant structures, much like Lorentz transformations in physics.

### **How It Works: The Hybrid Filter**

The main.py script demonstrates the theory in practice with a **Hybrid Filter** for primality testing. It does not test numbers in isolation but uses the Z-Metric to perform a dynamic, path-dependent analysis.

1. **Z-Metrics Calculation:** For each number, it calculates metrics based on a physics analogy:  
   * number\_mass: The number of divisors, analogous to rest mass.  
   * spacetime\_metric: The natural logarithm, representing the domain's fabric.  
   * z\_curvature & z\_resonance: Derived metrics that quantify the interaction between mass and spacetime.  
2. **The Observer:** Instead of a simple check, the classify\_with\_z\_score function analyzes the "geodesic path" from the last known prime to the current candidate.  
3. **The Adaptive Lens:** The filter's tolerance is not fixed. It uses a sigma\_multiplier that is dynamically calibrated by the candidate number's own "mass," creating a self-referential feedback loop.  
4. **The Oracle:** A high-certainty Miller-Rabin test (is\_prime) is used only when the low-cost Z-filter cannot confidently classify a candidate, conserving computational energy.

### **What This Repository Contains**

* **/src/main/main.py**: The primary proof-of-concept script. Run this to see the Z-Metric classifier in action.  
* **/src/main/docs/**: Detailed documentation, including analysis of the framework's application to various domains and risk assessments.  
* **/src/sandbox/**: Various experimental scripts and earlier versions of the classifier.  
* **prime\_stats\_hybrid\_filter.csv**: Example output data generated by running the main script.  
* **Z-Metric Whitepaper**: A high-density technical document detailing the core axioms and universal theory of the framework.

### **How to Run**

To run the proof of concept and generate a new statistics file:  
python src/main/main.py

You will see a summary of the filter's performance printed to the console, and a detailed CSV file will be saved to the root directory.
# Z Definition

## Universal Form

- Z = A(B/C)  
- A = reference frameâ€“dependent measured quantity  
- B = Rate  
- C = Invariant universal limit of B  

## Physical Domain

- Z = T(v/c)  
- T = reference frameâ€“dependent measured quantity  
- v = velocity  
- c = Invariant universal speed of light  
